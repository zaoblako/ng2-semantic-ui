{"version":3,"file":"tabset.js","sourceRoot":"","sources":["../../../../src/modules/tabs/components/tabset.ts"],"names":[],"mappings":"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","sourcesContent":["import { Component, ContentChildren, QueryList, AfterContentInit } from \"@angular/core\";\nimport { SuiTabHeader } from \"../directives/tab-header\";\nimport { SuiTabContent } from \"../directives/tab-content\";\nimport { Tab } from \"../classes/tab\";\n\n@Component({\n    selector: \"sui-tabset\",\n    template: `<ng-content></ng-content>`\n})\nexport class SuiTabset implements AfterContentInit {\n    @ContentChildren(SuiTabHeader)\n    private _tabHeaders:QueryList<SuiTabHeader>;\n\n    @ContentChildren(SuiTabContent)\n    private _tabContents:QueryList<SuiTabContent>;\n\n    // List of all tabs in the tabset.\n    public tabs:Tab[];\n\n    // Keeps track of the currently active tab.\n    private _activeTab:Tab;\n\n    public get activeTab():Tab {\n        return this._activeTab;\n    }\n\n    // When setting a tab as the currently active tab, it automatically gains\n    // `isActive` status (saves littering `isActive = true` everywhere).\n    public set activeTab(tab:Tab) {\n        this._activeTab = tab;\n        tab.isActive = true;\n    }\n\n    // Keeps track of the number of times `internalComponentsUpdated` is called.\n    private _barrierCount:number;\n\n    constructor() {\n        this.tabs = [];\n        this._barrierCount = 0;\n    }\n\n    public ngAfterContentInit():void {\n        // Fire `internalComponentsUpdated` when the query lists change.\n        this._tabHeaders.changes.subscribe(() => this.internalComponentsUpdated());\n        this._tabContents.changes.subscribe(() => this.internalComponentsUpdated());\n\n        // Initially load the tabs.\n        this.loadTabs();\n    }\n\n    // Fires whenever either the tab headers or tab contents query lists update.\n    private internalComponentsUpdated():void {\n        // We are using a 'counting barrier of n = 2', i.e. the code within only runs after the method is called twice.\n        // This is so that both the headers and contents query lists can update before we run code that matches the two up.\n        this._barrierCount++;\n\n        if (this._barrierCount === 2) {\n            // Reset the barrier so it can be called again.\n            this._barrierCount = 0;\n\n            // Update the tabs.\n            this.loadTabs();\n        }\n    }\n\n    // Connects tab headers to tab contents, and creates a tab instance for each pairing.\n    private loadTabs():void {\n        // Remove any tabs that no longer have an associated header.\n        this.tabs = this.tabs.filter(t => !!this._tabHeaders.find(tH => tH === t.header));\n\n        this._tabHeaders\n            // Filter out the loaded headers with attached tab instances.\n            .filter(tH => !this.tabs.find(t => t.header === tH))\n            .forEach(tH => {\n                const content = this._tabContents.find(tC => tC.id === tH.id);\n\n                if (!content) {\n                    // Error if an associated tab content cannot be found for the given header.\n                    throw new Error(\"A [suiTabHeader] must have a related [suiTabContent].\");\n                }\n\n                // Create a new tab instance for this header & content combo.\n                const tab = new Tab(tH, content);\n\n                // Subscribe to any external changes in the tab header's active state. External changes are triggered by user input.\n                tab.header.isActiveExternalChange.subscribe(() => this.onHeaderActiveChanged(tab));\n\n                // Add the new instance to the list of tabs.\n                this.tabs.push(tab);\n            });\n\n        // Assign each tab an index (which denotes the order they physically appear in).\n        this._tabHeaders\n            .forEach((tH, i) => {\n                const tab = this.tabs.find(t => t.header === tH);\n                if (tab) {\n                    tab.index = i;\n                }\n            });\n\n        // Sort the tabs by their index.\n        this.tabs.sort((a, b) => a.index - b.index);\n\n\n        if (!this.activeTab) { // Check if there are no current existing active tabs.\n            // If so, we must activate the first available tab.\n            this.activateFirstTab();\n        } else if (!this.tabs.find(t => t === this.activeTab)) { // O'wise check if current active tab has been deleted.\n            // If so, we must find the closest.\n            // Use `setTimeout` as this causes a 'changed after checked' error o'wise.\n            setTimeout(() => this.activateClosestTab(this.activeTab));\n        }\n\n        if (this.tabs.length === 0) {\n            // Error if there aren't any tabs in the tabset.\n            throw new Error(\"You cannot have no tabs!\");\n        }\n    }\n\n    // Fires whenever a tab header's active state is externally changed.\n    private onHeaderActiveChanged(tab:Tab):void {\n        // If the tab has become activated, but was not previously the active tab:\n        if (tab.isActive && this.activeTab !== tab) {\n            // Deactivate all of the tabs.\n            this.tabs.filter(t => t !== tab).forEach(t => t.isActive = false);\n\n            // Set the currently active tab to this one.\n            this.activeTab = tab;\n        }\n\n        // If the tab has become deactivated, but was previously the active tab:\n        if (!tab.isActive && this.activeTab === tab) {\n            // Activate the closest tab to it.\n            this.activateClosestTab(tab);\n        }\n    }\n\n    // Activate the first tab in the set.\n    public activateFirstTab():void {\n        this.activeTab = this.tabs[0];\n    }\n\n    // Activates the closest available tab to a given one.\n    public activateClosestTab(tab:Tab):void {\n        let nextAvailable:Tab | undefined;\n\n        // When the exited tab's index is higher than all available tabs,\n        if (tab.index >= this.tabs.length) {\n            // Activate the last tab.\n            nextAvailable = this.tabs[this.tabs.length - 1];\n        }\n\n        // If that didn't work, try the following cases:\n        if (!nextAvailable) {\n            if (!this.tabs.find(t => t === tab)) { // When the exited tab no longer exists,\n                // Replace it with a tab at the same index.\n                nextAvailable = this.tabs[tab.index];\n            } else { // Or if the exited tab still exists,\n                // Go to the tab immediately to the left.\n                nextAvailable = this.tabs[Math.max(tab.index - 1, 0)];\n            }\n        }\n\n        // However, if the chosen tab is disabled,\n        if (nextAvailable.isDisabled) {\n            // Activate the closest available tab to it.\n            return this.activateClosestTab(nextAvailable);\n        }\n\n        this.activeTab = nextAvailable;\n    }\n}\n"]}