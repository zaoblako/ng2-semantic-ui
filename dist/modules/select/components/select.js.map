{"version":3,"file":"select.js","sourceRoot":"","sources":["../../../../src/modules/select/components/select.ts"],"names":[],"mappings":"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","sourcesContent":["import { Component, ViewContainerRef, ViewChild, Output, EventEmitter, ElementRef, Directive, Input, Renderer2 } from \"@angular/core\";\nimport { ICustomValueAccessorHost, customValueAccessorFactory, CustomValueAccessor } from \"../../../misc/util/index\";\nimport { SuiLocalizationService } from \"../../../behaviors/localization/index\";\nimport { SuiSelectBase } from \"../classes/select-base\";\nimport { SuiSelectOption } from \"./select-option\";\n\n@Component({\n    selector: \"sui-select\",\n    template: `\n<!-- Query input -->\n<input suiSelectSearch\n       type=\"text\"\n       [hidden]=\"!isSearchable || isSearchExternal\">\n\n<!-- Placeholder text -->\n<div *ngIf=\"selectedOption == undefined\" class=\"default text\" [class.filtered]=\"query\">{{ placeholder }}</div>\n<!-- Selected item -->\n<div class=\"text\" [class.filtered]=\"query || selectedOption == undefined\">\n    <span #optionTemplateSibling></span>\n    <span *ngIf=\"!optionTemplate && selectedOption != undefined\" [innerHTML]=\"configuredFormatter(selectedOption)\"></span>\n</div>\n<!-- Dropdown icon -->\n<i class=\"{{ icon }} icon\" (click)=\"onCaretClick($event)\"></i>\n<!-- Select dropdown menu -->\n<div class=\"menu\"\n     suiDropdownMenu\n     [menuTransition]=\"transition\"\n     [menuTransitionDuration]=\"transitionDuration\"\n     [menuAutoSelectFirst]=\"isSearchable\">\n\n    <ng-content></ng-content>\n    <div *ngIf=\"isSearchable && availableOptions.length === 0\" class=\"message\">\n        {{ localeValues.noResultsMessage }}\n    </div>\n</div>\n`\n})\nexport class SuiSelect<T, U> extends SuiSelectBase<T, U> implements ICustomValueAccessorHost<U> {\n    public selectedOption?:T;\n    // Stores the value written by ngModel before it can be matched to an option from `options`.\n    private _writtenOption?:U;\n\n    @ViewChild(\"optionTemplateSibling\", { read: ViewContainerRef })\n    private _optionTemplateSibling:ViewContainerRef;\n\n    @Output()\n    public selectedOptionChange:EventEmitter<U>;\n\n    private _placeholder:string;\n\n    @Input()\n    public get placeholder():string {\n        return this._placeholder || this.localeValues.single.placeholder;\n    }\n\n    public set placeholder(placeholder:string) {\n        this._placeholder = placeholder;\n    }\n\n    constructor(element:ElementRef, renderer:Renderer2, localizationService:SuiLocalizationService) {\n        super(element, renderer, localizationService);\n\n        this.selectedOptionChange = new EventEmitter<U>();\n    }\n\n    protected optionsUpdateHook():void {\n        if (!this._writtenOption && this.selectedOption) {\n            // We need to check the option still exists.\n            this.writeValue(this.valueGetter(this.selectedOption));\n        }\n\n        if (this._writtenOption && this.searchService.options.length > 0) {\n            // If there was an value written by ngModel before the options had been loaded, this runs to fix it.\n            this.selectedOption = this.findOption(this.searchService.options, this._writtenOption);\n            if (this.selectedOption) {\n                this._writtenOption = undefined;\n                this.drawSelectedOption();\n            }\n        }\n    }\n\n    protected queryUpdateHook():void {\n        // When the query is updated, we just abandon the current selection.\n        this.selectedOption = undefined;\n    }\n\n    public selectOption(option:T):void {\n        // Choose and emit the selected option.\n        this.selectedOption = option;\n        this.selectedOptionChange.emit(this.valueGetter(option));\n\n        this.dropdownService.setOpenState(false);\n\n        this.resetQuery();\n\n        this.drawSelectedOption();\n\n        // Automatically refocus the search input for better keyboard accessibility.\n        this.focus();\n    }\n\n    public writeValue(value:U):void {\n        if (value != undefined) {\n            if (this.searchService.options.length > 0) {\n                // If the options have already been loaded, we can immediately match the ngModel value to an option.\n                this.selectedOption = this.findOption(this.searchService.options, value);\n\n                this.drawSelectedOption();\n            }\n            if (this.selectedOption == undefined) {\n                if (this.valueField && this.searchService.hasItemLookup) {\n                    // If the search service has a selected lookup function, make use of that to load the initial value.\n                    this.searchService\n                        .initialLookup(value)\n                        .then(i => {\n                            this.selectedOption = i;\n                            this.drawSelectedOption();\n                        });\n                } else {\n                    // Otherwise, cache the written value for when options are set.\n                    this._writtenOption = value;\n                }\n            }\n        } else {\n            this.selectedOption = undefined;\n            this.drawSelectedOption();\n        }\n    }\n\n    protected initialiseRenderedOption(option:SuiSelectOption<T>):void {\n        super.initialiseRenderedOption(option);\n\n        // Boldens the item so it appears selected in the dropdown.\n        option.isActive = option.value === this.selectedOption;\n    }\n\n    private drawSelectedOption():void {\n        // Updates the active class on the newly selected option.\n        if (this._renderedOptions) {\n            this.onAvailableOptionsRendered();\n        }\n\n        if (this.selectedOption != undefined && this.optionTemplate) {\n            this.drawTemplate(this._optionTemplateSibling, this.selectedOption);\n        }\n    }\n}\n\n// Value accessor directive for the select to support ngModel.\n@Directive({\n    selector: \"sui-select\",\n    host: {\n        \"(selectedOptionChange)\": \"onChange($event)\",\n        \"(touched)\": \"onTouched()\"\n    },\n    providers: [customValueAccessorFactory(SuiSelectValueAccessor)]\n})\nexport class SuiSelectValueAccessor<T, U> extends CustomValueAccessor<U, SuiSelect<T, U>> {\n    constructor(host:SuiSelect<T, U>) {\n        super(host);\n    }\n}\n"]}